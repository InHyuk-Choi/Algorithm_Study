# 0210 월요일 회식

# 0211 화요일 
## SEA.1267.작업순서

https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV18TrIqIwUCFAZN

공지사항에 있는 보충 A형 문제를 풀어보고 싶어서 선택했다.
완전탐색(DFS)란 카테고리 스포를 보고 시작했는데
오히려 나는 BFS가 떠올라서 그걸로 탐색했다.

문제의 내용을 요약하면
그래프(노드, 단방향 엣지) 데이터가 주어지는데 
선행관계에 대한 데이터로 노드을 체크하려면 전의 일을 마무리 해야한다.
그 순서를 출력하는 것으로 여러가지일 경우 하나만 제시하면 된다.

처음에는 인접리스트로 접근 했다가 어려움을 느끼고 인접행렬로 변경했다.
나가는 방향의 인접행렬을 뒤집어  들어오는 인접행렬까지 2가지를 만들었고
나가는 인접행렬로 탐색순서를 결정하고
들어오는 인접행렬로 탐색조건을 만들었다.

![image](https://github.com/user-attachments/assets/320e2b74-8a8f-43f3-9a15-bf38938aa669)

BFS 방향으로 이렇게 진행하면서
진행한 방향으로 간 뒤 들어오는 인접행렬에서 그 노드의 리스트를 열고
해당 화살표에 해당하는 위치를 0으로 바꾼 뒤 
해당 리스트의 원소가 전부 0일때만 큐에 추가했다.
그림과 같은 구조로 그래프를 재구성한 것으로 생각하면 된다.

몇 번 인덱스 조건을 놓는 위치가 틀려서 헤매긴 했지만 
생각한 대로 구성했더니 정답이 나와서 좋았다.

# 0212 수요일
## SEA.1248.공통조상

https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15PTkqAPYCFAYD

핵심 아이디어는 
트리 구조를 내려가는 방향의 인접리스트와 올라가는 방향의 인접리스트로 표현한 것이다.

공통 조상을 확인하기 위해
트리 구조에서 올라가는 방향의 인접리스트가 
무조건 단방향으로 구성되는 것을 이용했다.
비교할 두 노드에서 무조건적인 공통 조상인 루트까지 한칸씩 거슬러 올라가면서 
방문한 노드들을 set에 기록하고
둘의 교집합이 생기면 그 때 종료하고 반환하는 방법으로 구현했다.

서브 트리의 경우는 DFS를 이용해
각 노드를 1로 잡고 그 아래 카운트 값들을 합산해가면서 반환하는 방법으로
모든 노드의 서브 트리 값을 만들어서 
해당 노드의 인덱스에 서브 트리 값이 있는 새 리스트를 제작하는 방법으로 구현했다.

아마 이 2가지로 구현하지 않고 1번의 탐색으로 둘 다 하는 방법이 있긴 있을 텐데
머리가 아파서 나눠서 구했다.

## SEA.1249.보급로

https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15QRX6APsCFAYD#none

핵심 아이디어는
그 좌표까지 가는데 필요한 최소 비용을 나타내는 새로운 매트릭스를 만드는 것이다.

델타 탐색과 bfs 구조를 이용해 그 모든 새 매트릭스를 추가해가는 것이고
우리가 필요한 것 N-1, N-1에 해당하는 값이라 그걸 리턴한다.
여기서 중요했던 것은 새로운 매트릭스가 무한인 값으로 생성하는 것이다.
처음에 0이라 생각했다가 실패했었다.

아마도 이걸 조금만 더 조정하면 필요없는 좌표에서의 조사는 안 할 수 있을 거 같다.

# 0213 목요일
오늘은 IM대비 문제 풀이를 했다.
추천 받은 D1 문제들을 풀었는데 10분 컷을 목표로 시간을 보면서 해봤지만
풍선팡 보너스 게임은 시간을 훨씬 넘어버렸다.
행렬을 뒤집는 건  reversed_matrix = list(zip(*matrix)) 로 간단히 표현 가능한 걸 배웠다.
너무 어렵게 돌아가지만 않으면 금방 구현 가능할 거 같다. 

# 0214 금요일
## SEA.5656.벽돌깨기

문제 자체를 첨 봤을 땐 어떻게? 란 생각이 먼저 들었지만
막상 구조를 생각해보니 우리가 아는 것으로 만들 수 있었다.

구슬이 갈 수 있는 경우의 수를 세는 것도 bfs/dfs로 구현 가능,
벽돌을 터트리는 과정 자체도 bfs/dfs로 구현 가능,
중력효과 적용하는 것은 따로 구현하면
3가지 함수로 구조를 만들 수 있었다.

다만 조심해야했던 점은 인덱스 <<< 코드 길이가 늘어나니 진짜 조심해야했고
2차원 행렬이라 복사할때 얕은복사의 오류를 신경써야했다.

# 0215 토요일 비대면스터디

# 0216 일요일
## BOJ.1600.말이 되고픈 원숭이
기본적인 구조 자체는
BFS를 통해 같은 깊이를 탐색하면서 1씩 카운팅을 올리고 
목적지에 도달하면 그 카운팅을 반환해 최소 이동 값을 구하는 방식이다.

여기서 얻은 건 경로에 대한 visited 체킹을
3차원 visited 형태로 구현 가능하다는 것이다.
예를 들어 같은 위치에 있다고 하면
말처럼 움직일 수 있는 가능성 3번이 있을때와 2번이 있을때는
갈 수 있는 경로가 다르다.
이 경우를 분리하기 위해 정보를 하나 더 넣어서(말의 움직임 횟수)
3차원 정보로 저장을 하는 것이다.

물론 이는 숫자가 크면 너무 큰 메모리를 차지하므로
2차원으로 구현한 visited의 값을 1차원으로 더 활용하는 방법도 가능할 거 같았는데
이 부분에서 막혀서 헤매다가 3차원으로 구현한 걸로 통과하긴 했다.

나중에 gpt랑 티키타카 해보니
말의 움직임을 1씩 올리면서 카운팅 하는 게 아닌
남은 횟수를 기록해야했다.
남은 횟수가 기록된 횟수보다 적으면 어차피 새로운 길을 가지 않는다고 보고
그때만 추가하는 형태로 하면 구현이 가능헀다.

