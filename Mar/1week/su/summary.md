# 📄 4012_요리사
https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWIeUtVakTMDFAVH&

------------------------------
## 회고
> 문제를 꼼꼼히 읽지 않고 테케를 보면서 이해하는 습관 때문에 오래 걸렸다.  
식재료는 N // 2개를 뽑았어야 했으나, 항상 2개씩만 뽑는 것이라고 생각을 했었다.   
    `ex. N = 6인 경우,`   
    A음식: (식재료1, 식재료2, 식재료3)   
    B음식: (식재료4, 식재료5, 식재료6) 로 가능.  
    하지만 나는 아래처럼식재료는 꼭 2개만 뽑는 줄 알았다.  
    A음식: (식재료1, 식재료2)   
    B음식: (식재료3, 식재료4)  
하필 주어진 예제가 N=4였어서 실수를 알아차리기 어려웠다.


# 📄 1806_부분합
https://www.acmicpc.net/problem/1806

## 설계
acc_nums = [0] * (N + 1) # 누적합 리스트.  
sequence_li = [0] * (N + 1)  # i번째 숫자를 포함했을 때의 수열 길이  
answer = [INF] * (N + 1) # 수열의 합이 S이상이었을 경우 수열 길이 저장

입력 숫자마다 순회하며 최소 수열 길이를 찾는다.  
### 1. 누적합 구해놓기
### 2. i번째 숫자를 무조건 포함했을 때의 최소 수열 길이를 저장한다.
- i번째 숫자를 포함했을 때 합이 S 미만인 경우  
    - 길이[i] += 1
- i번째 숫자를 포함했을 때 합이 S 이상인 경우  
    - **<left 조정하기>**  
    누적합이 S보다 작아지는 순간, 그 누적합 index보다 한칸이전으로 left 조정하기
        ```
        for l in range(left, i + 1):
            if 누적합[i] - 누적합[l] < S:
                left = l - 1
                break
        ```
    - 길이 = i - left  
    - answer[i] = 길이
- i번째 숫자를 포함했을 때 합이 S인 경우  
    - 길이[i] += 1
    - answer[i] = 길이

### 3. 가능한 수열 중 최소 길이를 찾는다.
```
answer = min(answer)
```


## 1. 유의사항
수열 길이가 1인 경우도 고려하여 left 인덱스를 조정해야한다.  
따라서 for j in range(left, i)가 아닌 for j in range(left, i + 1)로 정해야 한다.

## 회고
> left를 조정한 뒤에, 수열 길이를 계산하는 부분을 설계할 때 뭉뚱그려 작성해두어서 코드짤 때 헷갈렸다. 명확하게 생각 후 진행할 것.

# 📄 2206_벽 부수고 이동하기
https://www.acmicpc.net/problem/2206
## 1. 잔잔바리 실수들
### [1] N, M 좌표 오류
문제에서 좌표 범위가 (1, 1) ~ (N, M)이다. 0이 아닌 1부터 시작한다는 것을 고려해야 한다.
- 목표 지점은 N-1, M-1이 되어야 한다.
- 범위 밖을 체크할 때, **nr >= N, nc >= M** 인지 확인해야 한다.   
    나는 목표 지점이 N-1, M-1이라 범위 밖도 nr >= N-1, nc >= M-1로 설정해야 된다고 잘못 생각했었다. 하지만 실제 좌표는 (0, 0) ~ (N-1, M-1)이므로 (N-1, M-1)도 이동할 수 있는 좌표가 맞다.

### [2] 거리 업데이트 실수
#### 수정 전 코드
```
visited[nr][nc][1] = graph[row][col] + 1 # 거리 업데이트
```

#### 수정 후 코드
이동 거리는 visited 배열에 저장하고 있었다.
```
visited[nr][nc][1] = visited[row][col][crushed] + 1 # 거리 업데이트
```

### [3] 얕은 복사 오류
```
visited = [[[-1, -1]] * M for _ in range(N)] # 얕은 복사 오류

visited = [[[-1, -1] for _ in range(M)] for _ in range(N)] # 깊은 복사 
```

### [4] visited 시작 위치 초기화 오류
시작점에서 출발할 때 벽 안 부순 차원만 거리를 업데이트 해서, 부순 차원에선 시작점을 다시 방문하게 되는 문제가 있었다.

#### 수정 후 코드
```
queue.append((0, 0, 0)) # row, col, 벽 부쉈는지
visited[0][0][0] = 1 # 벽 안 부순 차원 거리 업데이트
visited[0][0][1] = 1 # 벽 부순 차원 거리 업데이트
```


